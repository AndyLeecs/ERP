---
# &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;灯具进销存系统
# &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 详细设计描述文档
# &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V1.0 正式版

## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CuteGroup 
## &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2017-11-14
---
### 目录
1、[引言](#1)  
	1.1、[编制目的](#1.1)  
	1.2、[词汇表](#1.2)  
	1.3、[参考资料](#1.3)  
2、[产品概述](#2)  
3、[体系结构设计概述](#3)  
4、[结构视角](#4)   
5、[依赖视角](#5)  
  


<h2 id='1'> 1. 引言</h2>

<h5 id='1.1'> &nbsp;&nbsp;&nbsp;&nbsp; 1.1 编制目的</h5>
&nbsp;&nbsp;&nbsp;&nbsp;本报告详细完成对灯具进销存系统的详细设计，达到指导后续软件构造的目的，同时实现和测试人员及用户的沟通。  
&nbsp;&nbsp;&nbsp;&nbsp;本报告面向开发人员，测试人员及最终用户而编写，是了解系统的导航。  

<h5 id='1.2'> &nbsp;&nbsp;&nbsp;&nbsp;1.2词汇表</h5>
|词汇名称 |词汇含义| 备注|  
|---|---|---|  
|_ui|表示某展示层||  
|_bl|表示某逻辑层||  
|_data|表示某数据层||  

<h5 id='1.3'> &nbsp;&nbsp;&nbsp;&nbsp;1.3 参考资料</h5>
1、灯具进销存系统需求规格说明文档  
2、灯具进销存系统用例文档  
3、灯具进销存系统体系结构描述文档
  
<h2 id='2'> 2. 产品概述</h2>
&nbsp;&nbsp;&nbsp;&nbsp;参考灯具进销存系统用例文档和灯具进销存系统软件需求规格说明中对产品的概括描述。

  
<h2 id='3'> 3.体系结构设计概述</h2>
&nbsp;&nbsp;&nbsp;&nbsp;参考灯具进销存系统概要设计文档中对体系结构设计的概述。
  
<h2 id='4'> 4.结构视角</h2>
  
  
###4.1 业务逻辑层的分解
  
### 4.1.1 goods 模块
#### （1）模块描述
goodsbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求
goodsbl模块的职责及接口参见软件系统体系结构描述文档

#### （2）整体结构
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性和可修改性，我们会添加接口。在展示层和业务逻辑层之间，我们添加GoodsBLService接口。业务逻辑层和数据层之间添加GoodsDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们添加了GoodsBLServiceImpl，这样GoodsBLServiceImpl会将对新建的业务逻辑处理委托给Goods和GoodsCategory对象。GoodsPO和GoodsCategoryPO是作为商品和商品分类信息的持久化对象被添加到设计模型中去的。<br/>

goodsbl模块的设计如图4.1.1-1 所示

  
![](https://i.imgur.com/MbzkqFu.png)
**图 4.1.1（1）-1 goodsbl模块设计模型**<br/>

表 4.1.1-1（2） goodsbl模块各个类的职责<br/>

模块 | 职责
---|---
GoodsBLServiceImpl | 管理goodsbl各个类的任务
Goods | 完成对商品信息的增删改查任务
GoodsCategory | 完成对商品分类信息的增删改查任务

#### （3）模块内部类的接口规范
GoodsBLServiceImpl 的接口规范如表4.1.1（3）-1所示。<br/>
Goods的接口规范如表4.1.1（3）-2所示。<br/>
GoodsCategory的接口规范如表4.1.1（3）-3所示。<br/>

表4.1.1（3）-1 GoodsBLServiceImpl的接口规范
<table>
<tr>
<td colspan ="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的服务（供接口）</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.newGoodsID</td>
<td>语法</td> <td> public String newGoodsID(GoodsVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择新建商品</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示商品编号</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.findGoods</td>
<td>语法</td> <td> public List<GoodsVO> findGoods(String info,String type);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户输入信息模糊查找商品</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示模糊查找后符合要求的商品列表</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.deleteGoods</td>
<td>语法</td> <td> public ResultMessage deleteGoods(String category,String name);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择删除商品</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品列表</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.modifyGoods</td>
<td>语法</td> <td> public ResultMessage modifyGoods(GoodsVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择修改商品信息</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品信息</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.newGoodsCategoryAutoId</td>
<td>语法</td> <td>public ResultMessage newGoodsCategoryId(GoodsCategoryVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择新建商品分类</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品分类信息</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.deleteGoodsCategory</td>
<td>语法</td> <td>public ResultMessage deleteGoodsCategory(GoodsCategoryVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择删除商品分类</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品分类信息</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.modifyGoodsCategory</td>
<td>语法</td> <td>public ResultMessage modifyGoodsCategory(GoodsCategoryVO newVO);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择修改商品分类名称</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品分类信息</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.getCategory</td>
<td>语法</td> <td>public GoodsCategoryVO getCategory(String goodsCategoryName,String parentName);</td>
</tr>
<tr>
<td>前置条件</td><td>用户选择获取分类信息</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示分类信息</td>
</tr>
<tr>
<td rowspan="3">GoodsBLServiceImpl.getAllCategory</td>
<td>语法</td> <td>public List getAllCategory(String node);</td>
</tr>
<tr>
<td>前置条件</td><td>用户选择查看所有分类</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示所有分类</td>
</tr>
</table>
<table>
<tr>
<td colspan = "2">需要的服务（需接口）</td>
</tr>
<tr>
<td>服务名</td> <td>服务</td>
</tr>
<tr>
<td>Goods.newGoodsID(GoodsVO vo)</td> <td>新建商品</td>
</tr>
<tr>
<td>Goods.findGoods(String info,String type)</td> <td>模糊查找商品</td>
</tr>
<tr>
<td>Goods.deleteGoods(String category,String name)</td> 
<td>删除商品</td>
</tr>
<tr>
<td>Goods.modifyGoods(GoodsVO vo)</td> 
<td>修改商品信息</td>
</tr>
<tr>
<td>GoodsCategory.newGoodsCategoryAutoId(GoodsCategoryVO vo)</td> 
<td>新建商品分类</td>
</tr>
<tr>
<td>GoodsCategory.deleteGoodsCategory(GoodsCategoryVO vo)</td> 
<td>删除商品分类</td>
</tr>
<tr>
<td>GoodsCategory.modifyGoodsCategory(GoodsCategoryVO newVO)</td> 
<td>修改商品分类名</td>
</tr>
<tr>
<td>GoodsCategory.getCategory()</td> 
<td>获取商品分类信息</td>
</tr>
<tr>
<td>GoodsCategory.getAllCategory()</td> 
<td>获取所有商品分类</td>
</tr>
</table>

表4.1.1（3）-2 Goods 的接口规范
<table>
<tr>
<td colspan ="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的服务（供接口）</td>
</tr>
<tr>
<td rowspan="3">Goods.newGoodsID</td>
<td>语法</td> <td> public String newGoodsID(GoodsVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择新建商品</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示商品编号</td>
</tr>
<tr>
<td rowspan="3">Goods.findGoods</td>
<td>语法</td> <td> public List<GoodsVO> findGoods(String info,String type);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户输入信息模糊查找商品</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示模糊查找后符合要求的商品列表</td>
</tr>
<tr>
<td rowspan="3">Goods.deleteGoods</td>
<td>语法</td> <td> public ResultMessage deleteGoods(String category,String name);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择删除商品</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品列表</td>
</tr>
<tr>
<td rowspan="3">Goods.modifyGoods</td>
<td>语法</td> <td> public ResultMessage modifyGoods(GoodsVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择修改商品信息</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品信息</td>
</tr>
</table>
<table>
<td colspan = "2">需要的服务（需接口）</td>
</tr>
<tr>
<td>服务名</td> <td>服务</td>
</tr>
<tr>
<td>GoodsDataService.newGoodsID(GoodsVO vo)</td> <td>新建商品</td>
</tr>
<tr>
<td>GoodsDataService.findGoods(String info,String type)</td> <td>模糊查找商品</td>
</tr>
<tr>
<td>GoodsDataService.deleteGoods(String category,String name)</td> 
<td>删除商品</td>
</tr>
<tr>
<td>GoodsDataService.modifyGoods(GoodsVO vo)</td> 
<td>修改商品信息</td>
</tr>
</table>

表 4.1.1(3)-3 GoodsCategory 的接口规范
<table>
<tr>
<td colspan ="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的服务（供接口）</td>
</tr>
<tr>
<tr>
<td rowspan="3">GoodsCategory.newGoodsCategoryAutoId</td>
<td>语法</td> <td>public ResultMessage newGoodsCategoryAutoId(GoodsCategoryVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择新建商品分类</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品分类信息</td>
</tr>
<tr>
<td rowspan="3">GoodsCategory.deleteGoodsCategory</td>
<td>语法</td> <td>public ResultMessage deleteGoodsCategory(GoodsCategoryVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择删除商品分类</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品分类信息</td>
</tr>
<tr>
<td rowspan="3">GoodsCategory.modifyGoodsCategory</td>
<td>语法</td> <td>public ResultMessage modifyGoodsCategory(GoodsCategoryVO newVO);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择修改商品分类名称</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新商品分类信息</td>
</tr>
<tr>
<td rowspan="3">GoodsCategory.getCategory</td>
<td>语法</td> <td>public List getCategory();</td>
</tr>
<tr>
<td>前置条件</td><td>用户选择查看分类信息</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示分类信息</td>
</tr>
<tr>
<td rowspan="3">GoodsCategory.getAllCategory</td>
<td>语法</td> <td>public List getAllCategory();</td>
</tr>
<tr>
<td>前置条件</td><td>用户选择查看所有分类</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示所有分类</td>
</tr>
</table>
<table>
<tr>
<td colspan = "2">需要的服务（需接口）</td>
</tr>
<tr>
<td>服务名</td> <td>服务</td>
</tr>
<tr>
<td>GoodsDataService.newGoodsCategoryAutoId(GoodsCategoryVO vo)</td> 
<td>新建商品分类</td>
</tr>
<tr>
<td>GoodsDataService.deleteGoodsCategory(GoodsCategoryVO vo)</td> 
<td>删除商品分类</td>
</tr>
<tr>
<td>GoodsDataService.modifyGoodsCategory(GoodsCategoryVO vo)</td> 
<td>修改商品分类名</td>
</tr>
<tr>
<td>GoodsDataService.getCategory()</td> 
<td>获取商品分类信息</td>
</tr>
<tr>
<td>GoodsDataService.getAllCategory()</td> 
<td>获取所有商品分类</td>
</tr>
</table>

#### (4)业务逻辑层的动态模型
图4.1.1（4）-1表明了进销存系统中，当用户选择新建商品时，商品业务逻辑处理的相关对象之间的协作。<br/>
  
![](https://i.imgur.com/TCUyFnJ.png)
**图4.1.1（4）-1增加商品**<br/>

图4.1.1（4）-2表明了进销存系统中，当用户模糊查找商品时，商品业务逻辑处理的相关对象之间的协作。<br/>
  
![](https://i.imgur.com/0R54oIc.png)
**图4.1.1（4）-2模糊查找商品**<br/>

图4.1.1（4）-3表明了进销存系统中，当用户删除商品时，商品业务逻辑处理的相关对象之间的协作。<br/>
  
  
![](https://i.imgur.com/kPAfwQh.png)
**图4.1.1（4）-3删除商品**<br/>

图4.1.1（4）-4表明了进销存系统中，当用户修改商品信息时，商品业务逻辑处理的相关对象之间的协作。<br/>
![](https://i.imgur.com/MdYKBjw.png)
**图4.1.1（4）-4修改商品信息**<br/>

图4.1.1（4）-5表明了进销存系统中，当用户初始化并保存商品信息时，商品业务逻辑处理的相关对象之间的协作。<br/>
![](https://i.imgur.com/jk15Gr3.png)
**图4.1.1（4）-5初始化商品信息并保存**<br/>

图4.1.1（4）-6表明了进销存系统中，当用户新建商品分类时，商品业务逻辑处理的相关对象之间的协作。<br/>
  
![](https://i.imgur.com/kB7ABC6.png)
**图4.1.1（4）-6新建商品分类**<br/>

图4.1.1（4）-7表明了进销存系统中，当用户删除商品分类时，商品业务逻辑处理的相关对象之间的协作。<br/>
![](https://i.imgur.com/WzMHMTI.png)
**图4.1.1（4）-7删除商品分类**<br/>

图4.1.1（4）-8表明了进销存系统中，当用户修改商品分类名称时，商品业务逻辑处理的相关对象之间的协作。<br/>
![](https://i.imgur.com/4xr2L4C.png)
**图4.1.1（4）-8修改商品分类**<br/>

图4.1.1（4）-9表明了进销存系统中，当用户查看所有分类和商品时，商品业务逻辑处理的相关对象之间的协作。<br/>
![](https://i.imgur.com/8yJ7A0d.png)
**图4.1.1（4）-9查看所有分类和商品**<br/>

图4.1.1（4）-10所示的状态图描述Goods对象的生存期间的状态序列、引起转移的事件、以及因状态转移而伴随的动作。随着newGoodsId/findGoods/deleteGoods/modifyGoods方法被GoodsBLServiceImpl调用，Goods进入handleData状态；之后通过获取GoodsPO进入Present状态；通过获取ResultMessage进入Complete状态<br/>
![](https://i.imgur.com/vslx0e2.png)
**图4.1.1（4）-10 Goods对象状态图**<br/>

图4.1.1（4）-11所示的状态图描述GoodsCategory对象的生存期间的状态序列、引起转移的事件、以及因状态转移而伴随的动作。随着newGoodsCategoryAutoId/deleteGoodsCategory/modifyGoodsCategory/getCategory/getAllCategory方法被GoodsBLServiceImpl调用，GoodsCategory进入handleData状态；之后通过获取GoodsPO进入Present状态；通过获取ResultMessage进入Complete状态<br/>
![](https://i.imgur.com/ffh22xW.png)
**图4.1.1（4）-11 GoodsCategory对象状态图**<br/>  
  
  
### 4.1.2 VIP 模块
#### （1）模块描述
VIPbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求
VIPbl模块的职责及接口参见软件系统体系结构描述文档

#### （2）整体结构
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性和可修改性，我们会添加接口。在展示层和业务逻辑层之间，我们添加VIPBLService接口。业务逻辑层和数据层之间添加VIPDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们添加了VIPBLServiceImpl，这样VIPBLServiceImpl会将对新建的业务逻辑处理委托给VIP对象。VIPPO是作为商品和商品分类信息的持久化对象被添加到设计模型中去的。<br/>
  
**图4.1.2-1**
![](https://i.imgur.com/laZa3L0.png)  


VIPbl模块的设计如图4.1.2-1 所示

表 4.1.2-1（2） VIPbl模块各个类的职责<br/>

模块 | 职责
---|---
VIPBLServiceImpl | 完成对客户信息的增删改查的任务

#### （3）模块内部类的接口规范
VIPBLServiceImpl 的接口规范如表4.1.2（3）-1所示。<br/>

表4.1.2（3）-1 VIPBLServiceImpl的接口规范
<table>
<tr>
<td colspan ="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的服务（供接口）</td>
</tr>
<tr>
<td rowspan="3">VIPBLServiceImpl.newVIPID</td>
<td>语法</td> <td> public String newVIPID(VIPVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择新建客户</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示客户编号</td>
</tr>
<tr>
<td rowspan="3">VIPBLServiceImpl.getVIP</td>
<td>语法</td> <td> public VIPVO getVIP(String name);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择获取客户信息</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示客户信息</td>
</tr>
<tr>
<td rowspan="3">VIPBLServiceImpl.findVIP</td>
<td>语法</td> <td> public List findVIP(String info,String type);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户输入信息模糊查找客户</td>
</tr>
<tr>
<td>后置条件</td><td>系统显示模糊查找后符合要求的客户列表</td>
</tr>
<tr>
<td rowspan="3">VIPBLServiceImpl.deleteVIP</td>
<td>语法</td> <td> public ResultMessage deleteVIP(String name);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择删除客户</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新客户列表</td>
</tr>
<tr>
<td rowspan="3">VIPBLServiceImpl.modifyVIP</td>
<td>语法</td> <td> public ResultMessage modifyVIP(VIPVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>用户选择修改客户信息</td>
</tr>
<tr>
<td>后置条件</td><td>系统更新客户信息</td>
</tr>
</table>
<table>
<tr>
<td colspan = "2">需要的服务（需接口）</td>
</tr>
<tr>
<td>服务名</td> <td>服务</td>
</tr>
<tr>
<td>VIPDataService.newVIPID(VIPVO vo)</td> <td>新建会员</td>
</tr>
<tr>
<td>VIPDataService.getVIP(String name)</td> <td>获取会员信息</td>
</tr>
<tr>
<td>VIPDataService.findVIP(String info,String type)</td> <td>模糊查找会员</td>
</tr>
<tr>
<td>VIPDataService.deleteVIP(String name)</td> 
<td>删除会员</td>
</tr>
<tr>
<td>VIPDataService.modifyVIP(VIPVO vo)</td> 
<td>修改会员信息</td>
</tr>
</table>

#### (4)业务逻辑层的动态模型
图4.1.2（4）-1表明了进销存系统中，当用户选择初始化并保存客户信息时，客户业务逻辑处理的相关对象之间的协作。<br/>
![](https://i.imgur.com/wgZ2Vfu.png)
**图4.1.2（4）-1初始化并保存客户信息**<br/>

图4.1.2（4）-2所示的状态图描述VIP对象的生存期间的状态序列、引起转移的事件、以及因状态转移而伴随的动作。随着newVIPID/deleteVIP/modifyVIP方法被VIPBLServiceImpl调用，VIP进入handleData状态；之后通过获取VIPPO进入Present状态；通过获取ResultMessage进入Complete状态<br/>  

  
![](https://i.imgur.com/qCpY2bb.png)  
  

**图4.1.2（4）-2 VIP对象状态图**<br/>


  
### 4.1.3 sale 模块
#### （1）模块描述
salebl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求</br>
salebl模块的职责及接口参见软件系统体系结构描述文档

#### （2）整体结构
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性和可修改性，我们会添加接口。在展示层和业务逻辑层之间，我们添加SaleBLService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了 SaleBLServiceImpl，这样SaleBLBLServiceImpl会将针对多种单据的业务逻辑交给SaleForAll对象，会将针对销售单的业务逻辑处理交给SaleList对象，将针对销售退货单的业务逻辑处理交给SaleReturnList对象，将针对进货单的业务逻辑处理交给StockList对象，将针对进货退货单的业务逻辑处理交给StockReturnList对象，将针对所有单据共同部分的业务逻辑处理交给SalesmanList对象。而Bill和SaleItem的添加是GoodsVO的容器类。SalesmanListVO,SaleListVO,SaleReturnListVO,StockListVO,StockReturnListVO是作为销售人员单据的值对象被添加到设计模型中去的，GoodsVO是作为商品信息的值对象被添加到设计模型中去的，VIPVO是作为会员信息的值对象被添加到设计模型中去的，PresentResultVO是作为销售人员所需的使用赠送策略结果的值对象被添加到设计模型中的，SaleVO是作为生成赠送策略所需的销售单信息的值对象被添加到设计模型中的，SalesmanListPO,SaleListPO,SaleReturnListPO,StockListPO,StockReturnListPO是作为销售人员单据的持久化对象被添加到设计模型中去的。<br/>

salebl模块的设计如图4.1.2-1 所示

![image](http://101.37.19.32:10080/CuteGroup/Cute_Project/raw/7574bc97d00f78386a5736e9da1886066e0fdab3/doc/img/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3/salebl%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B.png)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**图 4.1.3（1）-1 salebl模块设计模型**<br/>

表 4.1.3-1（2） salebl模块各个类的职责<br/>

模块 | 职责
---|---
SaleBLServiceImpl|管理整合SaleBL各个类的任务，负责与其他bl模块交互 
SaleForAll | 负责协助处理涉及多种销售人员单据的服务
StockList | 负责协助处理涉及进货单的服务
StockReturnList | 负责协助处理涉及进货退货单的服务
SaleList | 负责协助处理涉及销售单的服务
SaleReturnList | 负责协助处理涉及销售退货单的服务
SalesmanList | 负责处理所有单据共同部分的服务，如获得会员信息，获得商品信息，记录操作日志
Bill | 负责计算总价和赠送策略
SaleItem | 负责计算小计

#### （3）模块内部类的接口规范
SaleBLServiceImpl的接口规范参见体系结构文档<br/>
SaleForAll,StockList,StockReturnList,SaleList,SaleReturnList的接口规范参见体系结构文档<br/>
表 SaleItem 的接口规范<br/>
<table>
<tr>
<td colspan ="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的服务（供接口）</td>
</tr>
<tr>
<tr>
<td rowspan="3">SaleItem.modifyQuantity</td>
<td>语法</td> <td>public ResultMessage modifyQuantity(String goodsid, int quantity);</td>
</tr>
<tr>
<td>前置条件</td> <td>商品存在</td>
</tr>
<tr>
<td>后置条件</td><td>改变数量</td>
</tr>
<tr>
<td rowspan="3">SaleItem.getTotal</td>
<td>语法</td> <td>public ResultMessage getTotal();</td>
</tr>
<tr>
<td>前置条件</td> <td>商品存在且数量存在</td>
</tr>
<tr>
<td>后置条件</td><td>返回小计</td>
</tr>
</table>
<table>
<tr>
<td colspan = "2">需要的服务（需接口）</td>
</tr>
<tr>
<td>服务名</td> <td>服务</td>
</tr>
<tr>
<td>GoodsInfo.getGoods</td> 
<td>获得商品信息</td>
</tr>
</table>

表 Bill 的接口规范
<table>
<tr>
<td colspan ="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的服务（供接口）</td>
</tr>
<tr>
<tr>
<td rowspan="3">Bill.refresh</td>
<td>语法</td> <td>public Bill refresh(DateUtil date, List<SaleItem>, String memberId, int sum);</td>
</tr>
<tr>
<td>前置条件</td> <td>单据中存在会员，商品名，商品数量等信息</td>
</tr>
<tr>
<td>后置条件</td><td>返回原价、使用的促销策略和总价</td>
</tr>
</table>
<table>
<tr>
<td colspan = "2">需要的服务（需接口）</td>
</tr>
<tr>
<td>服务名</td> <td>服务</td>
</tr>
<tr>
<td>SaleItem.getTotal</td> 
<td>获得表单商品的价格小计</td>
</tr>
</tr>
<tr>
<td>PresentBLInfo.findPresent</td> 
<td>获得促销策略</td>
</tr>
</table>

#### (4)业务逻辑层的动态模型

图4.1.3（4）-1表明了进销存系统中，当用户删除单据时，销售业务逻辑处理的相关对象之间的协作。其他同理。<br/>
![image](http://101.37.19.32:10080/CuteGroup/Cute_Project/raw/master/doc/img/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3/%E5%88%A0%E9%99%A4%E9%94%80%E5%94%AE%E7%B1%BB%E5%8D%95%E6%8D%AE.png)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**图4.1.3（4）-1删除单据**<br/>
![image](http://101.37.19.32:10080/CuteGroup/Cute_Project/raw/master/doc/img/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3/Sale%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81%E5%9B%BE.png)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**图4.1.3（4）-2 Sale对象状态图**<br/>
### 4.1.4 List模块  

####(1)模块描述
listbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求  
listbl模块的职责及接口参见软件系统体系结构描述文档  

####(2)整体结构
  
表单包（经过重构设计后）主要负责表单集中查看、批量审批、导出三大功能，是完全的委托式设计。每种可审批的单据在提交时向表单报注册InfoList(信息简表)。表单查看时显示InfoList。表单包对外提供Approvable接口，所有可审批单实现此接口，在批量审批时表单包根据单据类型集中调用不同的实现。此外，表单包还完成经营历程和销售明细表的查看和导出功能，需要主动获得外在数据，并将数据的计算委托给库存和销售包。自己不单独维护数据对象。<br/>

Listbl 模块的详细设计类图如图4.1.4-1所示  
  
**图4.1.4-1**  
![](https://i.imgur.com/4bCC0hs.png)
  
  
表4.1.4(2)  listbl 模块各个类的职责  
  
|模块|职责|
|----|---|
|ListblController|负责实现Listblservice接口所需要的表单查看、表单审批、表单导出功能，并将具体任务分派给模块内其他各类|
|InfoList_Impl|负责实现InfoList 的注册和转移   


####（3）模块内部类的接口规范  
  
表4.1.4（3）-1a   ListblController类的供接口  

|服务编号|项目|内容|
|---|---|---|
|listblserviceImpl.approve|语法| public ApproveRM approve(String id, GreatListType type)|
|  |前置条件|用户选择审批某个表单|
|  |后置条件|系统更新该表单的审批信息|
|listblserviceImpl.saledetail|语法|public ArrayList<SalesDetailListVO> openSaleDetailList()|
|  |前置条件|用户选择查看销售明细表|
|  |后置条件|系统显示销售明细类表的列表|  
|listblserviceImpl.bussinesssituation|语法|public BussinessSituationListVO openBussinessSituationList()|
|  |前置条件|用户选择查看经营情况表|
|  |后置条件|系统显示经营情况表|
|listblserviceImpl.openinfoList|语法|public ArrayList<InfoListVO> openInfoList()|
|  |前置条件|用户选择查看已经提交的表单信息简表|
|  |后置条件|系统显示待审批表单信息简表|
|listblserviceImpl.toExcelFile|语法|public ListRM bussinessSituationToExcel ( String path)|
|  |前置条件|用户选择导出表单|
|  |后置条件|系统显示导出信息（成功导出的文件地址或导出失败)|

表4.1.4（3）-1b   listblserviceImpl类的需接口   
 
|需要的服务名|需要的服务内容|
|---|----|
|SalesBussinessSituation.getSalesIncome|获取折让后销售总收入|
|SalesBussinessSituation.getSalesDiscount|获取销售折让总额|
|SalesBussinessSituation.getSalesReturnOutcome|获取销售退货总支出|
|SalesBussinessSituation.getStockReturnIncome|获取进货退货总收入|
|SalesBussinessSituation.getstockOutcome|获取进货总支出|
|StoreBussinessSituation.getOverflowIncome|获取商品报溢收入|
|StoreBussinessSituation.getlossOutcome|获取商品报损支出|
|GetSalesDetails.getSalesDetail|获取销售明细数据|

    
   
 

表4.1.4（3）-2a InfoListImpl类的供接口  

 
|服务编号|项目|内容|  
|----|--|---|
|InfoListImpl.register|语法|public ListRM register(InfoListVO vo)|
|  |前置条件|提交单据|
|  |后置条件|表单信息成功注册|
|InfoListImpl.modify|语法|public ListRM modify(boolean b, String id)|  
|  |前置条件|单据审批通过或被拒绝|


  
表4.1.4（3）-2b accountList类的需接口  

不需要层内接口，层间的数据接口见体系结构设计文档。  


  
 
  
####(4)业务逻辑层的动态模型
  
表单包中查看、审批、导出文件操作中，表示相关对象协作的顺序图由图4.1.4（4）-1表示

图4.1.4（4）-1
![](https://i.imgur.com/o4dG058.png)

表单包中各个表单对象的状态图在图4.1.4（4）-2中给出，在图中，对象被初始化后根据得到的信息和命令进入不同的状态，包括查看状态、审批状态、导出状态，在结束单次操作后对象生命期结束。

图4.1.4（4）-2  
![](https://i.imgur.com/RkujUWw.png)  
  
  
####（5）业务逻辑层的设计原理  
  纯委托式控制风格，每个界面需要访问的业务逻辑由各自的控制器委托给不同领域的对象。并通过向外提供接口避免了循环依赖的问题。在InfoList的设计上利用了CommitMessage模式减小耦合。其他设计原理从略。
  
  
  
  
### 4.1.5 User 模块
#### （1）模块描述
Userbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求
Userbl模块的职责及接口参见软件系统体系结构描述文档

#### （2）整体结构
在体系结构的设计基础上，进一步将层间接口细化，按照接口最小化原则将UserBLService接口拆分成PersonalInfoService，SystemManagerServicec，OperationLogService三部分，并分别用PersonalInfo，SystemManager，OperationLog三个业务逻辑对象实现它们。也将UserDataService拆分成MessageDataService，UserDataService，OperationDataService三部分。  

User模块的设计如图4.1.5-1 所示

![](doc/md/详细设计文档/User模块的详细设计方案.png)

**图 4.1.5（1）-1 Userbl模块设计模型**<br/>

表 4.1.5-1（2） Userbl模块各个类的职责<br/>

模块 | 职责
---|---
PersonalInfo| 完成个人用户所需的功能
SystemManager | 完成系统管理员所需的功能
OperationLog | 完成日志有关的功能  
Message|完成消息有关的功能  


#### （3）模块内部类的接口规范
PersonalInfo 的接口规范如表4.1.5（3）-1所示。  
SystemManager的接口规范如表4.1.5（3）-2所示。  
OperationLog的接口规范如表4.1.5（3）-3所示。  
Message的接口规范如表4.1.5（3）-4所示。  



表4.1.5（3）-1 PersonalInfo的接口规范

与体系结构描述文档中如下接口相同  
public ResultMessage login(String name, String password)   
public ResultMessage logout()   
public UserVO getCurrentUserInfo()	  
public ResultMessage changePassword(String oldPassword,String newPassword)   
public List<MessageVO> checkMessage()   

表4.1.5（3）-2 SystemManger的接口规范

与体系结构描述文档中如下接口相同  
public String newUser(String name)   
public ResultMessage initAndSave(UserVO vo)   
public ResultMessage delete(String id)   
public ResultMessage modify(UserVO vo)   
public List<UserVO> findUser(String info)   


表4.1.5（3）-3 OperationLog 的接口规范

<table>
<tr>
<td colspan ="3">提供的服务（供接口）</td>
</tr>
<tr>
<td rowspan = "3">saveOperation</td>
<td>语法</td><td>public ResultMessage saveOperation(OperationVO)</td>
</tr>
<tr>
<td>前置条件</td><td> 经理或财务人员已登陆 </td>
</tr>
<tr>
<td>后置条件</td><td>返回日志信息</td>
</tr>
</table>

以及体系结构描述文档中如下接口  
public List<OperationVO> viewLog()  


表 4.1.5(3)-4 Message 的接口规范

<table>
<tr>
<td colspan ="3">提供的服务（供接口）</td>
</tr>
<tr>
<td rowspan = "3">sendMessage</td>
<td>语法</td><td>public ResultMessage sendMessage(MessageVO vo, UserRole role)
</td>
</tr>
<tr>
<td>前置条件</td><td> 经理或财务人员已登陆 </td>
</tr>
<tr>
<td>后置条件</td><td>返回日志信息</td>
</tr>
<tr>
<td rowspan = "3">checkMessage</td>
<td>语法</td><td>public List<MessageVO> checkMessage(String id)</td>
</tr>
<tr>
<td>前置条件</td><td>完成一个完整操作</td>
</tr>
<tr>
<td>后置条件</td><td>持久化保存操作记录</td>
</tr>
</table>


#### (4)业务逻辑层的动态模型
图4.1.5（4）表明了进销存系统中，当用户登录以及查看消息时，商品业务逻辑处理的相关对象之间的协作。<br/>
  
![](https://i.imgur.com/jJwW2wx.png)

**图4.1.5（4）登录和增加商品**<br/>

其他的顺序图与此类似，在此不再赘述    
  
  
  
  
###4.1.6 Store模块
####(1)模块描述
storebl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求  
storebl模块的职责及接口参见软件系统体系结构描述文档  
  
库存类设计包括三套逻辑，其一是简单逻辑的集中处理，用storeblcontroller处理，使用的是集中式控制。另有DataSetter和DataSetter工具类用于VO-PO的转换，相当于对数据层接口做了包装处理。其二是单据继承树，库存报溢单/报损单继承自storeList,并各自含有审批、提交方法。其三是库存对外接口的实现类，即Store_InterfaceImpl类，负责实现对外提供的修改数据的方法。<br/>

Listbl 模块的详细设计类图如图4.1.6-1所示  
  
![](https://i.imgur.com/qQLCiTU.png)
  
  
表4.1.6(2)  storeblcontroller 模块各个类的职责  
  
|模块|职责|
|---|----|
|StoreblController|负责实现Storeblservice接口所需要的库存报损、库存报溢、库存赠送、库存查看、库存盘点功能，并将具体任务分派给模块内其他各类|
|ReportList|负责实现库存报溢单报损单的生成、提交等功能|
|presentList|负责实现库存赠送单的生成、提交等功能。|
|StoreInterface_Impl|负责处理库存类单据过审、商品和商品分类变动造成的库存数据变化|
  
  
####（3）模块内部类的接口规范  
  
表4.1.6（3）-1a   StoreblController类的供接口  

|服务编号|项目|内容|
|---|---|---|
|storeblserviceImpl.openReportList|语法|public List<\ReportListVO> openReportList(ListType lt，StateType st) | 
|  |前置条件|用户选择查看报告类单据，包括报损类、报溢类的草稿单、待审批单、通过单、未通过单|
|  |后置条件|系统显示该类表单的列表|
|storeblserviceImpl.openAlarmList|语法|public List <\AlarmListVO> openAlarmList()|
|  |前置条件|用户选择查看报警单列表|
|  |后置条件|系统显示该类表单的列表|
|storeblserviceImpl.openPresentList|语法|public List<\PresentListVO> openPresentList(StateType st)|
|  |前置条件|用户选择查看赠送单列表，可选择的状态为草稿单、待审批单、通过单、未通过单|
|  |后置条件|系统显示该类表单的列表|
|storeblserviceImpl.toExcelFile|语法|public String toExcel(	InventoryVO vo,String path)|
|  |前置条件|用户选择导出当天的库存盘点，生成Excel文件|
|  |后置条件|系统显示导出信息（成功导出的文件地址或导出失败）|
|storeblserviceImpl.newList|语法|public String newList(ListType type)|
|  |前置条件|用户选择新建单据|
|  |后置条件|系统自动计算并返回单据编号|
|storeblserviceImpl.saveReportList|语法|public ListRM saveReportList (ListType type , ListVO vo)|
|  |前置条件|用户选择保存报损或者报溢出类单据|
|  |后置条件|系统将该单据数据保存在草稿箱|
|storeblserviceImpl.savePresentList|语法|public ListRM savePresentList ( ListVO vo)|
|  |前置条件|用户选择保存赠送类单据|
|  |后置条件|系统将该单据数据保存在草稿箱|
|storeblserviceImpl.commit|语法|public ListRM commit (ListType type , String ID)|
|  |前置条件|用户选择提交某类型的单据|
|  |后置条件|系统将该单据提交，并更新单据状态为已经提交，并在表单类的已提交单据信息表中注册该单据的信息。（若该单据尚未保存在数据库，则界面层应先调用保存方法，再提交）|
|storeblserviceImpl.check|语法| public storeCheckVO store_check(String begintime,String endTime)|
|  |前置条件|用户设置查看时间段，并查看该时段的各类库存信息，具体信息项见用例文档|
|  |后置条件|系统返回该时间段内的各类库存信息|
|storeblserviceImpl.inventory|语法|public storeInventoryVO store_inventory(String day)|
|  |前置条件|用户设置查询日期，对该天进行库存查看|
|  |后置条件|系统返回该日的库存盘点结果|  
|storeblserviceImpl.getstore|语法|public StoreVO getStoreVO(String id)|
|  |前置条件|用户获取单个库存数据|
|  |后置条件|系统返回该库存项数据|
  
  
表4.1.6（3）-1b   StoreblController类的需接口   
 
|需要的服务名|需要的服务内容|
|---|----|
|DataSetter.insertAlarmListVO|插入库存报警单值对象|
|DataSetter.insertReportListVO|插入库存报告单值对象|
|DataSetter.insertPresentListVO|插入库存赠送单值对象|
|DataSetter.replaceReportListVO|替换库存报告单值对象|
|DataSetter.replacePresentListVO|替换库存赠送单值对象|
|DataGetter.getAllAlarmList|获取全部库存报警单|
|DataGetter.getReportList|获取全部库存报溢报损单|
|DataGetter.getPresentList|获取全部库存赠送单|
|DataGetter.calcID|计算某类单据新建时的编号|  
|DataGetter.checkID|检查库存项是否含有一个或一组商品的ID| 
|DataGetter.getReportListVO|获取单个库存报告单|  
|DataGetter.getPresentListVO|获取单个库存赠送单|  
  
 


**由于库存单据（报损、报溢、赠送）所有操作均相同，只有VO\PO中的数据项意义略有区别，故而只选择库存赠送单来说明供接口和需接口。**  
表4.1.6（3）-2a PresentList类的供接口(ReportList类与其相同)   
 
|服务编号|项目|内容|
|---|---|---|
|PresentList.commit|语法| public ResultMessage commit()|
|  |前置条件|用户选择提交单据|
|  |后置条件|保存单据为已提交状态并向表单数据库注册单据信息|
|PresentList.approvePresentList|语法|public ListRM approvePresentList(PresentListVO vo, boolean b)|
|  |前置条件|总经理打开单据，修改数据，并通过或拒绝审批|
|  |后置条件|更新相关数据库|
|PresentList.approve|语法|public ListRM Approve(String id)|
|  |前置条件|总经理批量审批单据|
|  |后置条件|修改相关数据库|  

  



  
表4.1.6（3）-2b PresentList类的需接口   
 
|需要的服务名|需要的服务内容|
|----|---|
|DataSetter.replaceReportListVO|替换库存报告单值对象|
|InfoList.modify|修改表单信息表的状态|
|InfoList.register|注册表单信息表|

    

  
  
表4.1.6（3）-3a StoreInterface_Impl类的供接口    

|服务编号|项目|内容|
|---|---|---|
|StoreInterface_Impl.new|语法|public storeRM addStoreItem(StoreVO vo)|
|  |前置条件|商品类新建了某项商品，并初始化了其库存值|
|  |后置条件|调用数据层接口，更新数据库|
|StoreInterface_Impl.add|语法| public storeRM plusNumber( String id, int adder,GreatListType type,double price) |
|  |前置条件|增加某项商品的库存|
|  |后置条件|调用数据层接口，删除该库存项的记录|
|StoreInterface_Impl.sub|语法|public storeRM minusNumber( String id, int subber,GreatListType type)|
|  |前置条件|降低某项商品的库存|
|  |后置条件|系统更新数据库|
|StoreInterface_Impl.check|语法| public boolean check(List<String> id, List<Integer> subber)|
|  |前置条件|表单过审批时，检查一组商品的库存数量是否足够|
|  |后置条件|如有一个商品库存不足，返回false，否则返回true|
|StoreInterface_Impl.autoPresentList|语法|public boolean createPresentList_auto(PresentListVO vo)|
|  |前置条件|带有赠品的销售单通过审批|
|  |后置条件|系统自动生成赠送单|
  
表4.1.6（3）-5b StoreInterface_Imp类的需接口  

|需要的服务名|需要的服务内容|
|----|---|
|DataSetter.addStoreLog|插入库存修改记录|
|DataSetter.insertStoreVO|插入单项库存记录|
|DataSetter.addStore|增加单个商品的库存数量|
|DataSetter.subStore|减少单个商品的库存数量|  
|DataGetter.getStoreVO|获得单个库存项记录|
  
    
注：DataGetter和DataSetter是库存模块的内部类，不对模块外提供服务。
  
####(4)业务逻辑层的动态模型
  
库存包中库存盘点、库存报告表示相关对象协作的顺序图由图4.1.6（4）-1表示：  
    
图4.1.6（4）-1
![](https://i.imgur.com/uxSIvcf.png)  
  
库存包中各个对象的状态图在图4.1.6（4）-2中给出，在图中，对象被初始化后根据得到的信息和命令进入不同的状态，包括增加状态、删除状态、修改状态、查找状态、计算状态，在结束单次操作后对象生命期结束。
  
图4.1.6（4）-2
 
![](https://i.imgur.com/qE4NRcz.png)  
  

####（5）业务逻辑层的设计原理  
 综合了三种控制风格，结合了集中式风格和领域对象的优点，使包逻辑结构清晰。业务逻辑层还在防御式编程上做了大量的处理。
  

### 4.1.7 Account 模块
#### （1）模块描述
Accountbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求
Accountbl模块的职责及接口参见软件系统体系结构描述文档

#### （2）整体结构
在体系结构的设计基础上，进一步将层间接口细化，按照接口最小化原则将AccountBLService接口拆分成FinanceListService，AccountManagerServicec，AccountInitService三部分，并分别用FinanceListServiceControllor，AccountManagement，AccountInit三个业务逻辑对象实现它们。其中，FinanceListServiceControllor又会将任务委托给具体的list类来处理。也将AcountDataService拆分成PaymentListDataService，CollectionListDataService，CashExpenseListDataService,AccountDataService四部分。   

Account模块的设计如图4.1.5-1 所示

![](doc/md/详细设计文档/Account模块的详细设计方案.png)

**图 4.1.5（1）-1 Accountbl模块设计模型**<br/>

表 4.1.5-1（2） Accountbl模块各个类的职责<br/>

模块 | 职责
---|---
FinanceListServiceControllor|统一控制与财务类单据相关的操作  
FinanceList|完成与三种单据都相关的功能   
AccountManagement|实现与账户管理有关的功能    
AccountInit|完成与期初建账有关的功能  
PaymentList|完成与付款单有关的功能  
CollectionList|完成与收款单有关的功能  
CashExpenseList|完成与现金费用单有关的功能  

#### （3）模块内部类的接口规范
FinanceListServiceControllor 的接口参见原型代码  
AccountManagement  的接口参见原型代码   
AccountInit  的接口参见原型代码 
PaymentList，CollectionList，CashExpenseList的接口同各种单据的通用接口，详细参见体系结构描述文档   

表4.1.7（3）-1 Financelist  的接口规范

<table>
<tr>
<td colspan ="3">提供的服务（供接口）</td>
</tr>
<tr>
<td rowspan = "3">OpenDraft</td>
<td>语法</td><td>public List<FinanceListVO> openDraft()</td>
</tr>
<tr>
<td>前置条件</td><td> 财务人员已登陆</td>
</tr>
<tr>
<td>后置条件</td><td>返回所有财务类草稿单列表</td>
</tr>
<tr>
<td rowspan = "3">OpenCommitted</td>
<td>语法</td><td>public List<FinanceListVO> openCommitted()</td>
</tr>
<tr>
<td>前置条件</td><td> 财务人员已登陆</td>
</tr>
<tr>
<td>后置条件</td><td>返回所有财务类已提交单列表</td>
</tr>
<tr>
<td rowspan = "3">findVIP</td>
<td>语法</td><td>public List<VIPVO> findVIP(String info)</td>
</tr>
<tr>
<td>前置条件</td><td>无</td>
</tr>
<tr>
<td>后置条件</td><td>返回符合关键词的会员列表</td>
</tr>
<tr>
<td rowspan = "3">findAccount</td>
<td>语法</td><td>public List<AccountVO> findAccount()</td>
</tr>
<tr>
<td>前置条件</td><td>无</td>
</tr>
<tr>
<td>后置条件</td><td>返回所有账户列表</td>
</tr>
</table>


### 4.1.8 Present 模块
#### （1）模块描述
presentbl模块承担的需求参见需求规格说明文档功能需求及相关非功能需求</br>
presentbl模块的职责及接口参见软件系统体系结构描述文档

#### （2）整体结构
根据体系结构的设计，我们将系统分为展示层、业务逻辑层、数据层。每一层之间为了增加灵活性和可修改性，我们会添加接口。在展示层和业务逻辑层之间，我们添加PresentBLService接口。业务逻辑层和数据层之间添加PresentDataService接口。为了隔离业务逻辑职责和逻辑控制职责，我们增加了PresentBLServiceImpl，这样PresentBLServiceImpl会将处理多种赠送策略的业务逻辑交给PresentForAll对象，将处理针对用户级别型赠送策略的业务逻辑交给PresentForMembership对象，将处理特价包型赠送策略的业务逻辑交给PresentForSpecialPackage对象，将处理针对总价型赠送策略的业务逻辑交给PresentForSum对象。在Present模块和Sale模块之间，我们添加了PresentInfo接口和PresentInfoImpl对象。这样PresentInfoImpl对象会将改变PresentResult领域对象的任务委派给PresentForMembershipHandler对象，PresentForSpecialPackageHandler对象和PresentForSumHandler对象。PresentVO,PresentForMembershipVO,PresentForSpecialPackageVO,PresentForSumVO是作为不同种策略的值对象，PresentResultVO是作为为销售模块提供的赠送策略信息的值对象，SaleVO是作为销售模块提供的赠送策略所需的值对象，PresentForMembershipPO,PresentForSpecialPackagePO,PresentForSumPO是作为不同种策略的持久化对象被添加到设计模型中去的。<br/>

presentbl模块的设计如图4.1.2-1 所示

![image](http://101.37.19.32:10080/CuteGroup/Cute_Project/raw/master/doc/img/%E8%AF%A6%E7%BB%86%E8%AE%BE%E8%AE%A1%E7%9B%B8%E5%85%B3/presentbl%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B.png)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
**presentbl模块设计模型**<br/>

表 presentbl模块各个类的职责<br/>

模块 | 职责
---|---
PresentBLServiceImpl | 管理控制PresentBL中负责增删改查服务的类
PresentForAll | 负责协助处理涉及多种赠送策略增删改查的服务
PresentForMembership | 负责协助处理针对用户级别的赠送策略增删改查的业务逻辑
PresentForSpecialPackage | 负责协助处理特价包型的赠送策略增删改查的业务逻辑
PresentForSum  | 负责协助处理针对总价的赠送策略增删改查的业务逻辑
PresentInfoImpl | 负责控制PresentBL中负责使用销售策略的类
PresentForMembershipHandler | 负责使用针对用户级别的赠送策略
PresentForSpecialPackageHandler | 负责使用特价包型的赠送策略
PresentForSumHandler | 负责使用针对总价的赠送策略
PresentResult | 销售模块所需的使用赠送策略结果的领域对象
#### （3）模块内部类的接口规范
PresentBLServiceImpl的接口规范<br>
参见体系结构文档中Present业务逻辑层模块的接口规范，后置条件为委托给接口对应的PresentForAll,PresentForMembership,PresentForSpecialPackage,PresentForSum类

PresentForAll,PresentForMembership,PresentForSpecialPackage,PresentForSum类的接口规范<br>
参见PresentBLServiceImpl中对应的接口规范，方法名与PresentServiceImpl相同

PresentInfo的接口规范如下表<br>
<table>
<tr>
<td colspan ="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的服务（供接口）</td>
</tr>
<tr>
<td rowspan="3">PresentInfo.findPresent</td>
<td>语法</td> <td> public PresentResultVO findPresent(SaleVO vo);</td>
</tr>
<tr>
<td>前置条件</td> <td>无</td>
</tr>
<tr>
<td>后置条件</td><td>调用PresentResultImpl的findPresent方法</td>
</tr>
<tr>
</table>

PresentResultImpl的接口规范如下表<br>
<table>
<tr>
<td colspan ="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;提供的服务（供接口）</td>
</tr>
<tr>
<td rowspan="3">PresentResultImpl.handle</td>
<td>语法</td> <td> public PresentResultVO handle(VIPGrade grade);</td>
</tr>
<tr>
<td>前置条件</td> <td>无</td>
</tr>
<tr>
<td>后置条件</td><td>按顺序调用PresentForSpecialPackage,PresentForSum,PresentForMembership的handle方法
<tr>
</table>

PresentForSpecialPackage,PresentForSum,PresentForMembership的供接口为各模块的handle方法，入口参数为对应的salevo中的参数</br>
PresentResult的供接口为各属性的setter</br>
PresentDataService的接口同体系结构文档对应接口</br>
<table>


  
<h2 id='5'> 5.依赖视角</h2>  

图5.1和图5.2是客户端和服务器端各自的包之间的依赖关系。  
  
**图5.1  客户端包图**  

![](https://i.imgur.com/cLdt8oK.png)
    
 
**图5.2   服务器端包图**  
  
![](https://i.imgur.com/GabBxGf.png)
